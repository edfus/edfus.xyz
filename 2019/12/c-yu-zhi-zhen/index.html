<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><title>《C与指针》笔记 | EDFUS&#39;s Blog</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="icon" href="/favicon.png"><meta name="theme-color" content="#222"><meta name="subject" content="EDFUS's Personal Blog"><meta http-equiv="content-language" content="zh-CN,en-us"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 4.2.0"></head><body><div id="container"><div id="wrap"><header id="header"><div id="banner"></div><div id="header-outer" class="outer"><div id="header-title" class="inner"><h1 id="logo-wrap"><a href="/" id="logo" style="cursor:default">EDFUS&#39;s Blog</a></h1></div><div id="header-inner" class="inner"><nav id="main-nav"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/">Home | 思</a> <a class="main-nav-link" href="/categories/tech">Tech | 物</a> <a class="main-nav-link" href="/about">About | 我</a> <a class="main-nav-link" href="/more">MORE | 实验&amp;阅读</a></nav><nav id="sub-nav"><a id="nav-search-btn" class="nav-icon" title="搜索"></a></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="edfus.xyz"></form></div></div></div></header><div class="outer"><section id="main"><article id="post-C与指针" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><ul class="article-header-tag-list" itemprop="keywords"><li class="article-header-tag-list-item"><a class="article-header-tag-list-link" href="/categories/tech/C/" rel="tag">C</a></li><li class="article-header-tag-list-item"><a class="article-header-tag-list-link" href="/categories/tech/笔记/" rel="tag">笔记</a></li></ul><time datetime="2019-12-03T16:00:00.000Z" itemprop="datePublished" class="article-date">2019-12-04</time><div class="article-category"><a class="article-category-link" href="/categories/tech/">tech</a></div><div class="post-date">updateDate:&nbsp;&nbsp;2019-12-19</div></div><div class="article-inner toc-on"><header class="article-header"><h1 class="article-title" itemprop="name">《C与指针》笔记</h1></header><div class="article-entry" itemprop="articleBody"><div id="toc"><div id="heading-index">目录</div><ol class="md-toc"><li class="md-toc-item md-toc-level-2"><a class="md-toc-link" href="#第二章-环境"><span class="md-toc-text">第二章-环境</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#define"><span class="md-toc-text">#define</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#条件编译"><span class="md-toc-text">条件编译</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#用-kbd-s-kbd-前缀表示静态变量-span-class-chineselangcomma-，-span-用-kbd-g-kbd-表示全局变量-span-class-chineselangcomma-，-span-用-kbd-m-kbd-表示结构体成员"><span class="md-toc-text">用s_前缀表示静态变量，用g_表示全局变量，用m_表示结构体成员</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#kbd-cmd-kbd-编译C程序"><span class="md-toc-text">cmd编译C程序</span></a></li></ol></li><li class="md-toc-item md-toc-level-2"><a class="md-toc-link" href="#第四章-语句"><span class="md-toc-text">第四章-语句</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#副作用-side-effect-：除了传值之外有其他作用的语句和表达式"><span class="md-toc-text">副作用 side effect ：除了传值之外有其他作用的语句和表达式</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#单独用一行来表示一条空语句而不是直接加在尾部"><span class="md-toc-text">单独用一行来表示一条空语句而不是直接加在尾部</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#用for循环来突出循环控制的表达式们"><span class="md-toc-text">用for循环来突出循环控制的表达式们</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#FALL-THRU"><span class="md-toc-text">&#x2F;* FALL THRU *&#x2F;</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#goto-会导致结构混乱-span-class-chineselangcomma-，-span-不易阅读和维护时才不用"><span class="md-toc-text">goto : 会导致结构混乱，不易阅读和维护时才不用</span></a></li></ol></li><li class="md-toc-item md-toc-level-2"><a class="md-toc-link" href="#第五章-操作符和表达式"><span class="md-toc-text">第五章-操作符和表达式</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#位操作"><span class="md-toc-text">位操作</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#逻辑右移和算数右移"><span class="md-toc-text">逻辑右移和算数右移 &gt;&gt;</span></a></li><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#用无符号整型进行移位操作"><span class="md-toc-text">用无符号整型进行移位操作</span></a></li><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#优先级及一些例子"><span class="md-toc-text">优先级及一些例子</span></a></li></ol></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#a-a-的本质"><span class="md-toc-text">++a a++的本质</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#kbd-短路求值-kbd-超级重要！"><span class="md-toc-text">短路求值 超级重要！</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#kbd-逗号操作符-kbd-一直忽略了"><span class="md-toc-text">逗号操作符 一直忽略了...</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#于是我自己写了个程序试试逗号操作符和-后缀……-5"><span class="md-toc-text">于是我自己写了个程序试试逗号操作符和++后缀……[^5]</span></a></li></ol></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#左值-右值"><span class="md-toc-text">左值 右值</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#算术转换-4"><span class="md-toc-text">算术转换[^4]</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#优先级和求值顺序"><span class="md-toc-text">优先级和求值顺序</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#指针相减得-span-style-color-3ECB3B-background-3F3F3F-ptrdiff-t-span"><span class="md-toc-text">指针相减得ptrdiff_t</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#浮点数（突然想起来了233）"><span class="md-toc-text">浮点数（突然想起来了233）</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#所有参数都是按值调用（相当于定义新变量并初始化）"><span class="md-toc-text">所有参数都是按值调用（相当于定义新变量并初始化）</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#缺省参数提升-default-argument-promotion"><span class="md-toc-text">缺省参数提升(default argument promotion)</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#打印-d（递归）"><span class="md-toc-text">打印%d（递归）</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#可变参数列表"><span class="md-toc-text">可变参数列表</span></a></li></ol></li><li class="md-toc-item md-toc-level-2"><a class="md-toc-link" href="#第八章-数组"><span class="md-toc-text">第八章-数组</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#sizeof-array-返回整个数组长度"><span class="md-toc-text">sizeof(array)返回整个数组长度</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#int-array-10-ap-array-2-ap-1-4-1-array-6"><span class="md-toc-text">int array[10], *ap &#x3D; array + 2; ap[-1] &#x3D; 4; 1[array] &#x3D; 6;</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#下标绝不会比指针更有效率-span-class-chineselangcomma-，-span-但指针有时会比下标更有效率"><span class="md-toc-text">下标绝不会比指针更有效率，但指针有时会比下标更有效率</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#不同写法在汇编时的区别P148"><span class="md-toc-text">不同写法在汇编时的区别P148</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#向函数传递数组时（实参：起始地址-span-class-chineselangcomma-，-span-形参：数组）-span-class-chineselangcomma-，-span-是否声明了一个新数组并初始化为实参的值？"><span class="md-toc-text">向函数传递数组时（实参：起始地址，形参：数组），是否声明了一个新数组并初始化为实参的值？</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#const"><span class="md-toc-text">const</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#数组的初始化"><span class="md-toc-text">数组的初始化</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#多维数组"><span class="md-toc-text">多维数组</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#多维数组抽象"><span class="md-toc-text">多维数组抽象</span></a></li><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#多维数组之数组名含义"><span class="md-toc-text">多维数组之数组名含义</span></a></li><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#多维数组间接访问（解引用）"><span class="md-toc-text">多维数组间接访问（解引用）</span></a></li></ol></li></ol></li><li class="md-toc-item md-toc-level-2"><a class="md-toc-link" href="#第九章-字符串-span-class-chineselangpause-、-span-字符和字节"><span class="md-toc-text">第九章-字符串、字符和字节</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#if-strlen-x-strlen-y-0"><span class="md-toc-text">if( strlen(x) - strlen(y) &gt;&#x3D; 0 )</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#char-strncpy-char-dst-char-const-src-sizr-t-len"><span class="md-toc-text">char *strncpy( char *dst, char const *src, sizr_t len)</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#char-strncat-char-dst-char-const-src-sizr-t-len"><span class="md-toc-text">char *strncat( char *dst, char const *src, sizr_t len)</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#int-strncmp-char-const-s1-char-const-s2-sizr-t-len"><span class="md-toc-text">int strncmp( char const *s1, char const *s2, sizr_t len)</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#char-strchr-char-const-str-int-ch-char-strrchr-char-const-str-int-ch"><span class="md-toc-text">char *strchr(char const *str, int ch); char *strrchr(char const *str, int ch);</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#span-style-color-3ECB3B-background-3F3F3F-strspn-span-span-style-color-3ECB3B-background-3F3F3F-strcspn-span-span-style-color-3ECB3B-background-3F3F3F-strtok-span-span-style-color-3ECB3B-background-3F3F3F-strerror-span-span-style-color-3ECB3B-background-3F3F3F-ctype-h-span"><span class="md-toc-text">strspn | strcspn | strtok | strerror | &lt;ctype.h&gt; |</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#内存操作（遇到NUL字节时不会停止操作）"><span class="md-toc-text">内存操作（遇到NUL字节时不会停止操作）</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#void-memcpy-void-dest-const-void-src-size-t-num"><span class="md-toc-text">void* memcpy(void* dest,const void* src,size_t num)</span></a></li><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#void-memset-void-str-int-value-size-t-num"><span class="md-toc-text">void* memset(void* str,int value,size_t num)</span></a></li></ol></li></ol></li><li class="md-toc-item md-toc-level-2"><a class="md-toc-link" href="#第十章-结构和联合"><span class="md-toc-text">第十章-结构和联合</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#聚合数据类型-aggregate-data-type-成员-member"><span class="md-toc-text">聚合数据类型(aggregate data type) 成员 (member)</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#comp-sa-4-c-comp-sa-4-c"><span class="md-toc-text">( (comp.sa)[4] ).c &#x3D; comp.sa[4].c</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#不完整声明实现结构体的嵌套"><span class="md-toc-text">不完整声明实现结构体的嵌套</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#成员重排以减少内存损失"><span class="md-toc-text">成员重排以减少内存损失</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#offsetof-type-member-stddef-h-返回该成员开始存储位置离结构开始存储位置距离"><span class="md-toc-text">offsetof( type, member ) (stddef.h) 返回该成员开始存储位置离结构开始存储位置距离</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#用指针传递结构体到函数以提高效率（但也要注意不被修改）"><span class="md-toc-text">用指针传递结构体到函数以提高效率（但也要注意不被修改）</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#位段"><span class="md-toc-text">位段</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#成员必须为int-signed-int-unsigned-int类型"><span class="md-toc-text">成员必须为int | signed int | unsigned int类型</span></a></li><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#注意事项："><span class="md-toc-text">注意事项：</span></a></li></ol></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#联合和枚举"><span class="md-toc-text">联合和枚举</span></a></li></ol></li><li class="md-toc-item md-toc-level-2"><a class="md-toc-link" href="#第11章-动态内存分配-include-stdlib-h"><span class="md-toc-text">第11章-动态内存分配#include &lt;stdlib.h&gt;</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#void-malloc-size-t"><span class="md-toc-text">void *malloc( size_t );</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#void-calloc-size-t-num-elements-size-t-element-size"><span class="md-toc-text">void *calloc( size_t num_elements, size_t element_size );</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#void-realloc-void-ptr-size-t-new-size"><span class="md-toc-text">void *realloc( void *ptr, size_t new_size );</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#undef-malloc-P224"><span class="md-toc-text">#undef malloc P224</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#检查是否调用成功"><span class="md-toc-text">检查是否调用成功</span></a></li></ol></li><li class="md-toc-item md-toc-level-2"><a class="md-toc-link" href="#第12章-使用结构和指针-第13章-高级指针话题"><span class="md-toc-text">第12章-使用结构和指针&#x2F;第13章-高级指针话题</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#苏小红那本书上的pr指针原来是previous的意思（可以声明为寄存器变量）"><span class="md-toc-text">苏小红那本书上的pr指针原来是previous的意思（可以声明为寄存器变量）</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#双链表（两个指针指向一前一后）（两个根指针）"><span class="md-toc-text">双链表（两个指针指向一前一后）（两个根指针）</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#函数只能返回标量值-span-class-chineselangcomma-，-span-不能返回数组"><span class="md-toc-text">函数只能返回标量值，不能返回数组</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#函数指针"><span class="md-toc-text">函数指针</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#int-f-int-float-返回整型值形参为整型和浮点型的函数的指针的数组"><span class="md-toc-text">int ( *f[ ] )( int, float ) 返回整型值形参为整型和浮点型的函数的指针的数组</span></a></li><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#int-f-int-f（编译器隐式转换为函数指针）与-f（显式转换）一样"><span class="md-toc-text">int f( int ); f（编译器隐式转换为函数指针）与&amp;f（显式转换）一样</span></a></li><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#函数指针数组运用"><span class="md-toc-text">函数指针数组运用</span></a></li></ol></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#main函数参数-int-main-int-argc-char-argv-char-envp-int-main-int-argc-char-argv-P265"><span class="md-toc-text">main函数参数 int main (int argc, char *argv[ ], char *envp[ ]) | int main(int argc,char **argv)P265</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#putchar-0123456789ABCDEF-value-16"><span class="md-toc-text">putchar( &quot;0123456789ABCDEF&quot; [value % 16] );</span></a></li></ol></li><li class="md-toc-item md-toc-level-2"><a class="md-toc-link" href="#第14章-预处理器"><span class="md-toc-text">第14章-预处理器</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#预定义符号-头文件-include-stdio-h-中"><span class="md-toc-text">预定义符号(头文件#include&lt;stdio.h&gt;中)</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#define-2"><span class="md-toc-text">#define</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#宏替换"><span class="md-toc-text">宏替换</span></a></li><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#span-style-color-3ECB3B-background-3F3F3F-argument-span"><span class="md-toc-text">#argument</span></a></li><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#宏与函数"><span class="md-toc-text">宏与函数</span></a></li><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#undef-移除一个宏定义"><span class="md-toc-text">#undef 移除一个宏定义</span></a></li><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#命令行定义P285"><span class="md-toc-text">命令行定义P285</span></a></li></ol></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#条件编译（见环境）"><span class="md-toc-text">条件编译（见环境）</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#文件包含"><span class="md-toc-text">文件包含</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#其他指令"><span class="md-toc-text">其他指令</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#error"><span class="md-toc-text">#error</span></a></li><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#line-progma-无效指令"><span class="md-toc-text">#line #progma #无效指令</span></a></li></ol></li></ol></li><li class="md-toc-item md-toc-level-2"><a class="md-toc-link" href="#第15章-输入-输出函数"><span class="md-toc-text">第15章-输入&#x2F;输出函数</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#void-perror-char-const-message-include-stdio-h-errno-errno-h"><span class="md-toc-text">void perror( char const *message ); #include&lt;stdio.h&gt; errno &lt;errno.h&gt;</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#void-exit-int-status"><span class="md-toc-text">void exit( int status );</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#ANSI-I-O"><span class="md-toc-text">ANSI I&#x2F;O</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#program-data-answer"><span class="md-toc-text">$ program &lt; data &gt; answer</span></a></li><li class="md-toc-item md-toc-level-4"><a class="md-toc-link" href="#打开文件的最大数量FOPEN-MAX-（至少是8）与FILENAME-MAX"><span class="md-toc-text">打开文件的最大数量FOPEN_MAX （至少是8）与FILENAME_MAX</span></a></li></ol></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#span-style-color-3ECB3B-background-3F3F3F-fread-span-span-style-color-3ECB3B-background-3F3F3F-fwrite-span-用于读取（写入）二进制数据"><span class="md-toc-text">fread | fwrite用于读取（写入）二进制数据</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#fopen-打开一个特定流用于容纳）-a-若文件不存在-span-class-chineselangcomma-，-span-会创建该文件"><span class="md-toc-text">fopen(打开一个特定流用于容纳） &quot;a&quot; 若文件不存在，会创建该文件</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#FILE-freopen-char-const-filename-char-const-mode-FILE-stream"><span class="md-toc-text">FILE *freopen(char const *filename, char const *mode, FILE *stream );</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#int-ungetc-int-character-FILE-stream-将先前读入的字符返回流中"><span class="md-toc-text">int ungetc( int character, FILE *stream ); 将先前读入的字符返回流中</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#int-sscanf-char-const-string-char-const-format-从字符串中读取字符"><span class="md-toc-text">int sscanf( char const *string, char const *format,...)从字符串中读取字符</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#scanf-span-style-color-3ECB3B-background-3F3F3F-xxx-span-格式码"><span class="md-toc-text">scanf [xxx] 格式码</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#printf格式标志-0"><span class="md-toc-text">printf格式标志 - 0 + #</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#printf-d-“原样替换”"><span class="md-toc-text">printf %*d “原样替换”</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#二进制I-O-（效率很高-span-class-chineselangcomma-，-span-用于另一个程序将按顺序阅读时）"><span class="md-toc-text">二进制I&#x2F;O （效率很高，用于另一个程序将按顺序阅读时）</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#刷新和定位函数"><span class="md-toc-text">刷新和定位函数</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#改变缓存方式P318"><span class="md-toc-text">改变缓存方式P318</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#流错误函数"><span class="md-toc-text">流错误函数</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#临时文件"><span class="md-toc-text">临时文件</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#文件操作函数"><span class="md-toc-text">文件操作函数</span></a></li></ol></li><li class="md-toc-item md-toc-level-2"><a class="md-toc-link" href="#第16章-标准函数库P327"><span class="md-toc-text">第16章-标准函数库P327</span></a></li><li class="md-toc-item md-toc-level-2"><a class="md-toc-link" href="#第17章-经典抽象数据类型"><span class="md-toc-text">第17章-经典抽象数据类型</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#define-STACK-TYPE-int-push-pop"><span class="md-toc-text">#define STACK_TYPE int | push | pop</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#循环数组-front下标和rear下标分两头"><span class="md-toc-text">循环数组: front下标和rear下标分两头</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#二叉搜索树"><span class="md-toc-text">二叉搜索树</span></a></li><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#define实现泛型"><span class="md-toc-text">define实现泛型</span></a></li></ol></li><li class="md-toc-item md-toc-level-2"><a class="md-toc-link" href="#第十八章-运行时环境"><span class="md-toc-text">第十八章-运行时环境</span></a><ol class="md-toc-child"><li class="md-toc-item md-toc-level-3"><a class="md-toc-link" href="#汇编P420"><span class="md-toc-text">汇编P420</span></a></li></ol></li></ol></div><hr><p>注：用脚注[^n]来表示我的疑惑<span class="chineselangcomma">，</span>下方写解答或NULL<span class="chineselangstop">。</span>原本我的笔记都是写在本子上的<span class="chineselangcomma">，</span>但毕竟冬天手冷<span class="chineselangcomma">，</span>唯有笔记本的暖意喜人<span class="chineselangstop">。</span></p><p>书是《C与指针》（pointers on C）08年第二版<span class="chineselangcomma">，</span>人民邮电出版社<span class="chineselangstop">。</span></p><p>不只是书上的<span class="chineselangcomma">，</span>也有一些在网上找的内容<span class="chineselangstop">。</span></p><p>NUL指'\000'</p><p>阅读感受：虽然这本书叫C与指针<span class="chineselangcomma">，</span>但它对我在其他方面的帮助远比在指针方面的大w 因为我自己之前就已经把指针给折腾通了哈哈</p><p>以前查过的东西就略过了</p><p>12/19 写完</p><hr><p>UP-20-06-01:<br>初学时写的东西（笔记性质）<span class="chineselangcomma">，</span>也有为了尝试md这种记录方式的意思<span class="chineselangstop">。</span></p><p>顺便一提这之后我就没再用过纸质工具记录东西了<span class="chineselangstop">。</span></p><hr><h2 id="第二章-环境">第二章-环境</h2><h3 id="define">#define</h3><p><a href="https://blog.csdn.net/king110108/article/details/80728010" target="_blank" rel="noopener"><strong>#define用法集锦(非常全)</strong></a></p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN3(a,b,c) ((a)&lt;(b)?((a)&lt;(c)?(a):(c)):((b)&lt;(c)?(b):(c)))</span></span><br><span class="line"><span class="comment">//注意用括号括起（替换&lt;span class='chineselangcomma'&gt;，&lt;/span&gt;不多谈</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> MIN3(a,b,c) <span class="comment">//清除定义</span></span></span><br></pre></td></tr></table></figure></blockquote><h3 id="条件编译">条件编译</h3><blockquote><p>用条件编译<span class="chineselangcomma">，</span>通过预编译指令设置编译条件<span class="chineselangcomma">，</span>在不同的需要时编译不同的代码<span class="chineselangstop">。</span>(移植<span class="chineselangpause">、</span>软件更新）</p></blockquote><blockquote><ol><li><p><code>#if</code> <code>#elif</code><sup>elseif</sup> <code>#else</code> <code>#endif</code></p></li><li><p><code>#ifdef</code> <code>#else</code> <code>#endif</code> 或 <code>#ifndef</code> <code>#else</code> <code>#endif</code><br>（若有定义和若无定义）<sup>防止反复定义</sup></p></li><li><p>通过宏函数define<span style="color:red">d</span>（macro_name）//直接写宏名<span class="chineselangcomma">，</span>若定义过返回非0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TRIAL_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRIAL_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MIN3)         <span class="comment">//MIN3才是宏名</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN3(a,b,c) ((a)&lt;(b)?((a)&lt;(c)?(a):(c)):((b)&lt;(c)?(b):(c)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MAX_LEN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LEN (18)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>					<span class="comment">//每个#if执行到下一个#endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(MIN3) || (!defined(MAX_LEN) &amp;&amp; defined(TRIAL_H_INCLUDED))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyPrintf</span><span class="params">(<span class="keyword">char</span>* fmt, <span class="keyword">char</span>* args, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　　 ...				<span class="comment">//全局变量&lt;span class='chineselangcomma'&gt;，&lt;/span&gt;函数……</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TRIAL_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="用-kbd-s-kbd-前缀表示静态变量-span-class-chineselangcomma-，-span-用-kbd-g-kbd-表示全局变量-span-class-chineselangcomma-，-span-用-kbd-m-kbd-表示结构体成员">用<kbd>s_</kbd>前缀表示静态变量<span class="chineselangcomma">，</span>用<kbd>g_</kbd>表示全局变量<span class="chineselangcomma">，</span>用<kbd>m_</kbd>表示结构体成员</h3><h3 id="kbd-cmd-kbd-编译C程序"><kbd>cmd</kbd>编译C程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\冬眠在夏天&gt;gcc -c ddd.c   <span class="comment">//c++:g++ 让目标文件ddd.o不被删除（注意不是a.o!)</span></span><br><span class="line"></span><br><span class="line">C:\Users\冬眠在夏天&gt;gcc -o ddd ddd.c  <span class="comment">//重命名生成的exe文件&lt;span class='chineselangcomma'&gt;，&lt;/span&gt;只对exe文件生成命令有效</span></span><br><span class="line">       </span><br><span class="line">C:\Users\冬眠在夏天&gt;gcc aaa.c ddd.c	<span class="comment">//编译并链接&lt;span class='chineselangcomma'&gt;，&lt;/span&gt;当源文件有多个时&lt;span class='chineselangcomma'&gt;，&lt;/span&gt;目标文件不被删除</span></span><br><span class="line">    </span><br><span class="line">C:\Users\冬眠在夏天&gt;gcc aaa.o ddd.c	<span class="comment">//编译一个源文件并与现存的目标文件链接（这就是↑的原因）</span></span><br><span class="line"></span><br><span class="line">C:\Users\冬眠在夏天&gt;ddd          <span class="comment">//注意编译器是可以debug的,可执行文件后缀可省略</span></span><br><span class="line">please input <span class="number">3</span> values</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">max</span>:<span class="number">1</span></span><br><span class="line">C:\Users\冬眠在夏天&gt;ddd.exe &lt;input.txt&gt; output.txt</span><br><span class="line">    <span class="comment">/*please input 3 values</span></span><br><span class="line"><span class="comment">						//output.txt里的值（input.txt里的值是1\n2\n3\n) </span></span><br><span class="line"><span class="comment">	max:0*/</span>				<span class="comment">//很明显是我为了健壮性而加的fflush(stdin);的锅</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">while(!(ret = scanf("%d",&amp;a))||ret == -1)&#123;</span></span><br><span class="line"><span class="comment">	if(getc(stdin)==-1)</span></span><br><span class="line"><span class="comment">	&#123;	</span></span><br><span class="line"><span class="comment">		printf("");</span></span><br><span class="line"><span class="comment">		return ;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">C:\Users\冬眠在夏天&gt;gcc -o link.exe aaa.c ddd.c</span><br><span class="line">C:\Users\冬眠在~<span class="number">1</span>\AppData\Local\Temp\ccT8kr7f.o:ddd.c:(.<span class="built_in">text</span>+<span class="number">0x0</span>): multiple definition of `Compare3<span class="number">'</span></span><br><span class="line">C:\Users\冬眠在~<span class="number">1</span>\AppData\Local\Temp\ccUuschQ.o:aaa.c:(.<span class="built_in">text</span>+<span class="number">0x0</span>): first defined here</span><br><span class="line">collect2.exe: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure><ul><li>如上29~32行<span class="chineselangcomma">，</span>不能在<strong>多个源文件中包含同一份有函数定义的头文件</strong><sub>（为什么标准头文件可以呢?）</sub> [^1]</li><li><a href="https://blog.csdn.net/M_jianjianjiao/article/details/84109955" target="_blank" rel="noopener">原因是</a><strong>预处理阶段每个源文件是分开处理的</strong><span class="chineselangcomma">，</span>只有最后的链接阶段才在一起</li><li><strong>链接时<span class="chineselangcomma">，</span>文件名在前的先执行</strong><sup>（我猜）</sup> [^2]</li><li>头文件里的函数好像不能引用标准头文件里的函数[^3]</li></ul><h2 id="第四章-语句">第四章-语句</h2><h3 id="副作用-side-effect-：除了传值之外有其他作用的语句和表达式">副作用 side effect ：除了传值之外有其他作用的语句和表达式</h3><p>如i++ / printf(&quot;&quot;);</p><h3 id="单独用一行来表示一条空语句而不是直接加在尾部">单独用一行来表示一条空语句而不是直接加在尾部</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( <span class="built_in">scanf</span>(<span class="string">""</span>, &amp; )== )</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure><h3 id="用for循环来突出循环控制的表达式们">用for循环来突出循环控制的表达式们</h3><h3 id="FALL-THRU">/* FALL THRU */</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>( ch )&#123;				<span class="comment">//括号前后都要有空格,强转不用加空格</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'\n'</span>:				<span class="comment">//带意义的字符</span></span><br><span class="line">        lines ++;</span><br><span class="line">         <span class="comment">/* FALL THRU */</span>	<span class="comment">//合理注释</span></span><br><span class="line">        </span><br><span class="line">    case '':</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">        words ++;</span><br><span class="line">        <span class="comment">/* FALL THRU */</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        chars ++;</span><br><span class="line">&#125;							<span class="comment">//可是我觉得有些规范并不易读&lt;span class='chineselangcomma'&gt;，&lt;/span&gt;比如&amp;&amp;前后都要空格 (._.`)</span></span><br></pre></td></tr></table></figure><h3 id="goto-会导致结构混乱-span-class-chineselangcomma-，-span-不易阅读和维护时才不用">goto : 会导致结构混乱<span class="chineselangcomma">，</span>不易阅读和维护时才不用</h3><p>考虑用函数包裹后return 或者递归调用？</p><h2 id="第五章-操作符和表达式">第五章-操作符和表达式</h2><h3 id="位操作">位操作</h3><h4 id="逻辑右移和算数右移">逻辑右移和算数右移 &gt;&gt;</h4><ul><li>逻辑右移：左边移入的位均用0填充</li><li>算数右移：左边移入的位<strong>均</strong>用符号位值填充</li></ul><h4 id="用无符号整型进行移位操作">用无符号整型进行移位操作</h4><blockquote><p>a &lt;&lt; -5 : 某台机器上左移27位（为啥时27？-5+32？不应该是符号位读作数据位吗？）</p></blockquote><h4 id="优先级及一些例子">优先级及一些例子</h4><ol><li><pre><code class="language-c"> value = value | 1 &lt;&lt; bit_number;   //将指定的bit_number+1位数设为一
 // 注意 ~ 优先级2，&lt;&lt; &gt;&gt;优先级5&lt;span class='chineselangcomma'&gt;，&lt;/span&gt;&amp; 优先级8&lt;span class='chineselangcomma'&gt;，&lt;/span&gt;^ 优先级9&lt;span class='chineselangcomma'&gt;，&lt;/span&gt; | 优先级10 
 // &amp;&amp;优先级11 ||优先级12 :?优先级13 =优先级14 ,优先级15
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;c</span><br><span class="line">    &#x2F;&#x2F;比 x * pow(2,n) 效率更高的 x &lt;&lt; n</span><br><span class="line">    &#x2F;*另外复习一下math.h: sqrt(x) | fabs(x) | log(x) | log10(x) | exp(x) | sin(x) *&#x2F;</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="language-c"> //用位操作进行不需中间变量的交换值操作 ^ XOR
 a ^= b;
 b ^= a;			//计算机中所有数都以补码的形式存储
 a ^= b;   //( a ^ b ) ^ a = b 加密技术
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. &#96;&#96;&#96;c</span><br><span class="line">    &#x2F;&#x2F; &amp;</span><br><span class="line">        x &amp; 1 &#x3D;&#x3D; 0 ? 偶数 : 奇数 </span><br><span class="line">        x &amp; 255 &#x2F;&#x2F;取低8位</span><br><span class="line">        x &amp; x-1 &#x3D;&#x3D; 0 &#x2F;&#x2F; 100000 与011111 判断是否是2的幂  &#x2F;* + - 的优先级为4 *&#x2F;</span><br></pre></td></tr></table></figure></code></pre></li></ol><h3 id="a-a-的本质">++a a++的本质</h3><p>增值操作符的本质是复制一份变量值的拷贝</p><p>区别不过是前缀在复制前增加<span class="chineselangcomma">，</span>后缀在复制后增加<span class="chineselangstop">。</span>（别忘了后缀的执行条件是遇到<kbd>;</kbd>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++a = <span class="number">10</span>;  a++ = <span class="number">10</span>; <span class="comment">//怎能向一个值赋值呢？</span></span><br></pre></td></tr></table></figure><h3 id="kbd-短路求值-kbd-超级重要！"><kbd><strong>短路求值</strong></kbd> <sup>超级重要！</sup></h3><p><span style="color:#3ecb3b;background:#3f3f3f">&amp;&amp; ||操作符</span>会先对左操作数进行求值<span class="chineselangcomma">，</span>当左值使表达式明显不可能成立时，<span style="color:#fff!important">右操作数被放弃</span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( x &gt;= <span class="number">0</span> &amp;&amp; x &lt; MAX &amp;&amp; <span class="built_in">array</span>[x] == <span class="number">0</span> )    <span class="comment">//注意&amp; | == 等无此性质</span></span><br></pre></td></tr></table></figure><h3 id="kbd-逗号操作符-kbd-一直忽略了"><kbd><strong>逗号操作符</strong></kbd> <sup>一直忽略了...</sup></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expression1, expression2, expression3, ..., expressionN  <span class="comment">//从左到右以此求值&lt;span class='chineselangcomma'&gt;，&lt;/span&gt;整个式子的值为最后一个expressionN</span></span><br><span class="line">    <span class="keyword">while</span>( i = <span class="number">0</span>, j = <span class="number">0</span>, count_value( a = get_value() ), a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       						 ...					<span class="comment">//将循环控制语句集中&lt;span class='chineselangcomma'&gt;，&lt;/span&gt;并利于修改</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="于是我自己写了个程序试试逗号操作符和-后缀……-5">于是我自己写了个程序试试逗号操作符和++后缀……[^5]</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  temp = <span class="number">0</span>, a = <span class="number">-1</span>, b = <span class="number">-1</span>, c = <span class="number">-1</span>,x1 = <span class="number">-1</span>,x2 = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    temp =</span><br><span class="line">    (a = temp++),</span><br><span class="line">    (x1 = temp),</span><br><span class="line">    (b = temp++ <span class="number">-1</span>),</span><br><span class="line">    (x2 = temp),</span><br><span class="line">    (c = temp++);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"temp1=%d,a=%d,x1=%d,b=%d,x2=%d,c=%d\n"</span>,temp,a,x1,b,x2,c);</span><br><span class="line"></span><br><span class="line">    temp = <span class="number">0</span>, a = <span class="number">-1</span>, b = <span class="number">-1</span>, c = <span class="number">-1</span>,x1 = <span class="number">-1</span>,x2 = <span class="number">-1</span>;</span><br><span class="line">    temp =(a = temp++),(x1 = temp),(b = temp++ <span class="number">-1</span>),(x2 = temp),(c = temp++);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"temp0=%d,a=%d,x1=%d,b=%d,x2=%d,c=%d\n"</span>,temp,a,x1,b,x2,c);</span><br><span class="line"></span><br><span class="line">    temp = <span class="number">0</span>, a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    temp =</span><br><span class="line">    temp++,</span><br><span class="line">    temp++ <span class="number">-1</span>,</span><br><span class="line">    temp++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"temp2=%d\n"</span>,temp);</span><br><span class="line"></span><br><span class="line">    temp = <span class="number">0</span>;</span><br><span class="line">    temp = temp++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"temp3=%d\n"</span>,temp);</span><br><span class="line"></span><br><span class="line">    temp = <span class="number">0</span>;</span><br><span class="line">    temp = temp++, temp++, temp++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"temp4=%d\n"</span>,temp);</span><br><span class="line"></span><br><span class="line">    temp = <span class="number">0</span>;</span><br><span class="line">    temp = (temp++);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"temp5=%d\n"</span>,temp);</span><br><span class="line"></span><br><span class="line">    temp = <span class="number">0</span>;</span><br><span class="line">    temp = temp++ <span class="number">-1</span>, temp++ <span class="number">-1</span>, temp++ <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"temp6=%d\n"</span>,temp);</span><br><span class="line"></span><br><span class="line">    temp = <span class="number">0</span>;</span><br><span class="line">    temp = temp++ <span class="number">-1</span>, temp++ <span class="number">-1</span>, temp++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"temp7=%d\n"</span>,temp);</span><br><span class="line"></span><br><span class="line">    temp = <span class="number">0</span>;</span><br><span class="line">    a = temp++,</span><br><span class="line">    temp++ <span class="number">-1</span>,</span><br><span class="line">    (b = temp++) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"temp8=%d,a=%d,b=%d\n"</span>,temp,a,b);</span><br><span class="line"></span><br><span class="line">    temp = <span class="number">0</span>, a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    a = temp++,<span class="number">-1</span>,temp++ <span class="number">-1</span>,(b = temp++) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"temp8=%d,a=%d,b=%d\n"</span>,temp,a,b);</span><br><span class="line"></span><br><span class="line">    temp = <span class="number">0</span>, a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    a = (temp++,<span class="number">-1</span>,temp++ <span class="number">-1</span>,(b = temp++));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"temp8=%d,a=%d,b=%d\n"</span>,temp,a,b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    temp = ((temp++)++)++;</span></span><br><span class="line"><span class="comment">//    printf("temp4=%d",temp);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左值-右值">左值 右值</h3><p>左值：标识了一个可预期<span class="chineselangpause">、</span>确定的能存储结果值的地点的值<span class="chineselangcomma">，</span>可以放在赋值符号左边</p><p>右值：大部分表达式<span class="chineselangpause">、</span>所有字面值常量……</p><h3 id="算术转换-4">算术转换[^4]</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">long</span> c = a * b;     <span class="comment">//在十六位机器上会产生溢出 </span></span><br><span class="line"><span class="keyword">long</span> c = (<span class="keyword">long</span>)a * b; 	<span class="comment">//正确的做法 (为什么？）</span></span><br><span class="line"><span class="comment">/*或*/</span><span class="keyword">long</span> c = <span class="number">5000l</span>*<span class="number">25l</span>; <span class="comment">//suffix</span></span><br></pre></td></tr></table></figure><h3 id="优先级和求值顺序">优先级和求值顺序</h3><ol><li><p>乘除优先级3 加减4 位移5 比较6 判等7 &amp;8 ^9 |10 &amp;&amp;优先级11 ||优先级12 :?优先级13 =优先级14 ,优先级15</p></li><li><pre><code class="language-c"> a * b     //部分1
     +				//左边的加法运算必须要先比右边的执行
     c * d   //部分2
     +
     e * f   //部分3
     = g;           //实际上部分1&lt;span class='chineselangpause'&gt;、&lt;/span&gt;部分2&lt;span class='chineselangpause'&gt;、&lt;/span&gt;部分3的进行先后顺序是不确定的（看编译器）
 /*所以*/
 f(x) + g(x) + h(x) //三个函数调用的顺序不确定&lt;span class='chineselangcomma'&gt;，&lt;/span&gt;若为I/O或函数里修改了静态变量值&lt;span class='chineselangcomma'&gt;，&lt;/span&gt;最好不用
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 第六章-指针</span><br><span class="line"></span><br><span class="line">### 内存（边界）对齐</span><br><span class="line"></span><br><span class="line">### 现代编译器对整型和地址（指针）已有区分</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">&#x2F;&#x2F;所以</span><br><span class="line">*100 &#x3D; 25; &#x2F;&#x2F;是错的</span><br><span class="line">*(void *)100 &#x3D; 25  &#x2F;&#x2F;这样才行（所以说还是抽象成数据类型了&lt;span class&#x3D;&#39;chineselangcomma&#39;&gt;，&lt;&#x2F;span&gt;没我想的那么自由）</span><br><span class="line">    char ch;</span><br><span class="line">*(void *)&amp;ch &#x3D; 11111;	&#x2F;&#x2F;数据类型</span><br></pre></td></tr></table></figure></code></pre></li></ol><h3 id="指针相减得-span-style-color-3ECB3B-background-3F3F3F-ptrdiff-t-span">指针相减得<span style="color:#3ecb3b;background:#3f3f3f">ptrdiff_t</span></h3><ol><li><p><strong>只有当两个指针都指向同一个数组里的元素时<span class="chineselangcomma">，</span>才能有效地相减</strong></p></li><li><p>两个指针相减的结果是<span style="color:#3ecb3b;background:#3f3f3f">ptrdiff_t</span><span class="chineselangcomma">，</span>一种有符号整数类型<span class="chineselangcomma">，</span>值为两个指针<strong>以数组长度为单位</strong>在内存中的距离</p></li><li><pre><code class="language-c"> p1 = &amp;array[i];
 p2 = &amp;array[j];
 p1 - p2 = i - j;
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 对指针进行关系运算</span><br><span class="line"></span><br><span class="line">1. 只有当两个指针都指向**同一个数组中的元素**时&lt;span class&#x3D;&#39;chineselangcomma&#39;&gt;，&lt;&#x2F;span&gt;他们之间才能进行有效的&lt;kbd&gt;&lt;&lt;&#x2F;kbd&gt;&lt;kbd&gt;&gt;&lt;&#x2F;kbd&gt;&lt;kbd&gt;&lt;&#x3D;&lt;&#x2F;kbd&gt;&lt;kbd&gt;&gt;&#x3D;&lt;&#x2F;kbd&gt;运算</span><br><span class="line"></span><br><span class="line">## 第七章-函数</span><br><span class="line"></span><br><span class="line">### 将函数定义的返回值和函数名提行写</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">int *		&#x2F;&#x2F;</span><br><span class="line">    FintFloat( int,int,float [N] )	&#x2F;&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">		&#x2F;&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><h3 id="浮点数（突然想起来了233）">浮点数（突然想起来了233）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,a^=<span class="number">-1</span>); <span class="comment">// a = -3 计算机中所有数都以补码的形式存储</span></span><br><span class="line"><span class="number">-1L</span> = <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span></span><br><span class="line">    <span class="comment">/*已知一个单精度浮点数用16进制数表示为：0xC0B40000&lt;span class='chineselangcomma'&gt;，&lt;/span&gt;求此浮点数所表达的实数&lt;span class='chineselangstop'&gt;。&lt;/span&gt;*/</span></span><br><span class="line">C <span class="number">0</span> B <span class="number">4</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1100</span> <span class="number">0000</span> <span class="number">1011</span> <span class="number">0100</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">按照浮点数格式切割成相应的域 <span class="number">1</span> (<span class="number">1000</span> <span class="number">0001</span>) (<span class="number">01101</span> <span class="number">000000000000000000</span>)</span><br><span class="line">    <span class="comment">/*阶码：*/</span> <span class="number">2</span>^<span class="number">7</span> + <span class="number">1</span> = <span class="number">129</span>, <span class="number">129</span> - <span class="number">127</span> = <span class="number">2</span>;</span><br><span class="line">	<span class="comment">/*尾数：*/</span> <span class="number">1.01101</span> = <span class="number">2</span>^<span class="number">0</span> + <span class="number">2</span>^<span class="number">-2</span> + <span class="number">2</span>^<span class="number">-3</span> +<span class="number">2</span>^<span class="number">-5</span></span><br></pre></td></tr></table></figure><p><strong>规范4字节单精度型浮点数和规范8字节双精度浮点数：</strong></p><table cellspacing="0" cellpadding="2" border="1" align="center" style="font-size:14px;word-wrap:nowrap"><tbody><tr><td valign="top">精度&nbsp;</td><td valign="top" style="text-align:center">符号位</td><td valign="top" style="text-align:center">阶码</td><td valign="top" style="text-align:center">尾数</td><td valign="top" style="text-align:center">表示公式</td><td valign="top" style="text-align:center">偏移量</td></tr><tr><td valign="top">单精度</td><td valign="top"><p>1（第31位）</p></td><td valign="top"><p>8（30到23位）</p></td><td valign="top"><p>23（22到0位）</p></td><td valign="top"><p>(-1)^S*2(P-127)*1.M</p></td><td valign="top">127</td></tr><tr><td valign="top">双精度</td><td valign="top"><p>1（第63位）</p></td><td valign="top"><p>11（62到52位）</p></td><td valign="top"><p>52（51到0位）</p></td><td valign="top"><p>(-1)^S*2(P-1023)*1.M</p></td><td valign="top">1023</td></tr></tbody></table><br><p><strong>阶码<span class="chineselangpause">、</span>移码<span class="chineselangpause">、</span>尾数</strong></p><p><span style="color:#3ecb3b;background:#3f3f3f">阶码</span>通常使用<span style="color:#3ecb3b;background:#3f3f3f">移码</span>表示（移码和补码只有符号位相反<span class="chineselangcomma">，</span>其余都一样)</p><p><span style="color:#3ecb3b;background:#3f3f3f">阶码</span>可以为正数<span class="chineselangcomma">，</span>也可以为负数<span class="chineselangcomma">，</span>为了处理负指数的情况<span class="chineselangcomma">，</span>实际的指数值按要求需要加上一个偏差（Bias）值作为保存在指数域中的值<span class="chineselangcomma">，</span>单精度数的偏差值为127<span class="chineselangcomma">，</span>双精度数的偏差值为1023<span class="chineselangstop">。</span></p><p><span style="color:#3ecb3b;background:#3f3f3f">尾数</span>的首位一定是1<span class="chineselangcomma">，</span>所以通常省略**（二进制的最大有效位必为1）**<span class="chineselangcomma">，</span>实际上用23位长的尾数域表达了24位的尾数</p><p><strong>非规范浮点数</strong></p><p>当两个绝对值极小的浮点数相减后<span class="chineselangcomma">，</span>其差值的指数可能超出允许范围<span class="chineselangcomma">，</span>最终只能近似为0<span class="chineselangstop">。</span>为了解决此类问题<span class="chineselangcomma">，</span>IEEE标准中引入了非规范（Denormalized）浮点数<span class="chineselangcomma">，</span>规定当浮点数的指数为允许的最小指数值时<span class="chineselangcomma">，</span>尾数不必是规范化（Normalized）的<span class="chineselangstop">。</span>有了非规范浮点数<span class="chineselangcomma">，</span>去掉了隐含的尾数位的制约<span class="chineselangcomma">，</span>可以保存绝对值更小的浮点数<span class="chineselangstop">。</span>而且<span class="chineselangcomma">，</span>由于不再受到隐含尾数域的制约<span class="chineselangcomma">，</span>上述关于极小差值的问题也不存在了<span class="chineselangcomma">，</span>因为所有可以保存的浮点数之间的差值同样可以保存<span class="chineselangstop">。</span>（<strong>所以说为什么要用fabs(a-b) &lt;= 1e-6啊</strong>）</p><h3 id="所有参数都是按值调用（相当于定义新变量并初始化）">所有参数都是按值调用（相当于定义新变量并初始化）</h3><h3 id="缺省参数提升-default-argument-promotion">缺省参数提升(default argument promotion)</h3><p><span style="color:#3ecb3b;background:#3f3f3f">K&amp;R C</span>旧式函数声明风格参数传递和<span style="color:#3ecb3b;background:#3f3f3f">可变参数</span>传递（这些都没有对形参进行类型声明<sup>原型</sup>）时<span class="chineselangcomma">，</span><code>char</code>和<code>short</code>型被提升为<code>int</code>型<span class="chineselangcomma">，</span><code>float</code>被提升为<code>double</code>型</p><h3 id="打印-d（递归）">打印%d（递归）</h3><p>原谅我第一想法是用堆栈来做😂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">    binary_to_ascii( <span class="keyword">unsigned</span> <span class="keyword">int</span> value )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> quotitent = <span class="number">0</span>;</span><br><span class="line">    								<span class="comment">//分割</span></span><br><span class="line">    quotitent = value/<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>( quotitent != <span class="number">0</span> )</span><br><span class="line">        binary_to_ascii( quotitent );  <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">putchar</span>( <span class="string">'0'</span> + value % <span class="number">10</span> );	   <span class="comment">//使用'0'增加可读性和移植性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变参数列表">可变参数列表</h3><ol><li><p>头文件：<span style="color:#3ecb3b;background:#3f3f3f">&lt;stdarg.h&gt;</span>是必需的</p></li><li><p>可变参数的宏们无法判断参数数量<span class="chineselangpause">、</span>类型<span class="chineselangcomma">，</span>只能通过之前的<span style="color:#3ecb3b;background:#3f3f3f">命名参数</span>和确定的数据类型进行应用</p></li><li><p>可变参数列表应用步骤：</p><blockquote><ol><li><p>用<span style="color:#3ecb3b;background:#3f3f3f">va_list</span>定义一个变量</p></li><li><p>用<span style="color:#3ecb3b;background:#3f3f3f">va_start</span>向<span style="color:#3ecb3b;background:#3f3f3f">va_list</span>型变量赋值<span class="chineselangcomma">，</span>用<span style="color:#3ecb3b;background:#3f3f3f">可变参数</span>列表前的前一个参数名做标记</p></li><li><p>用<span style="color:#3ecb3b;background:#3f3f3f">va_arg</span>访问可变参数<span class="chineselangcomma">，</span>第二个形参规定访问下一个<span style="color:#3ecb3b;background:#3f3f3f">参数</span>用何种数据类型<span class="chineselangcomma">，</span>只能按顺序从前往后访问<span class="chineselangcomma">，</span>返回参数值<span class="chineselangstop">。</span></p></li><li><p>访问完最后一个<span style="color:#3ecb3b;background:#3f3f3f">可变参数</span>后<span class="chineselangcomma">，</span>调用<span style="color:#3ecb3b;background:#3f3f3f">va_end</span>( );结束</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">type <span class="title">va_arg</span><span class="params">(va_list argptr, type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_end</span><span class="params">(va_list argptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_start</span><span class="params">(va_list argptr, last_parm)</span></span>;</span><br></pre></td></tr></table></figure></li></ol></blockquote></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="comment">//类型：va_list 宏：va_start, va_arg, va_end</span></span><br><span class="line"><span class="keyword">float</span></span><br><span class="line">    Average( <span class="keyword">int</span> n_values, ... )</span><br><span class="line">&#123;</span><br><span class="line">    va_list var_arg;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ** 访问可变参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    va_start( va_arg, n_values );  <span class="comment">//第二个参数是可变参数列表前的最后一个数&lt;span class='chineselangcomma'&gt;，&lt;/span&gt;第一个参数指明可变参数列表的存储位置（应该是吧……）即命名参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ** 可变参数参与求值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>( count = <span class="number">0</span>; count &lt; n_values; count++ )&#123;</span><br><span class="line">        sum += va_arg( var_arg, <span class="keyword">int</span> );      <span class="comment">//第二个参数为数据类型&lt;span class='chineselangcomma'&gt;，&lt;/span&gt;第一个为va_list型数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ** 完成参数处理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    va_end( var_arg );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum / n_values;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tryout.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyprintIntu(<span class="string">"\n共打印了%d个字符"</span>,MyprintIntu(<span class="string">"试试怎么用MyprintIntu: 我的成绩是全校前%d%%,今天是入校%u天\\\n庄养浩"</span>,<span class="number">100</span>,<span class="number">999</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;			//stdin/stdout/putc由stdio.h规定</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">    binary_to_ascii( <span class="keyword">unsigned</span> <span class="keyword">int</span> value )    <span class="comment">//在下面有引用的函数需要写在前面</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> quotitent = <span class="number">0</span>;</span><br><span class="line">    								<span class="comment">//分割</span></span><br><span class="line">    quotitent = value/<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>( quotitent != <span class="number">0</span> )</span><br><span class="line">        binary_to_ascii( quotitent );  <span class="comment">//递归</span></span><br><span class="line">    <span class="built_in">putchar</span>( <span class="string">'0'</span> + value % <span class="number">10</span> );	   <span class="comment">//使用'0'增加可读性和移植性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyprintIntu</span><span class="params">(<span class="keyword">char</span> store[], ... )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list va_store;</span><br><span class="line">    va_start( va_store, store );</span><br><span class="line">    <span class="comment">//初始化可变参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p_to_char = store;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ; *p_to_char != <span class="string">'\0'</span>; p_to_char++ )</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( *p_to_char == <span class="string">'%'</span> )</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span>( *(p_to_char + <span class="number">1</span>) == <span class="string">'d'</span> || *(p_to_char + <span class="number">1</span>) == <span class="string">'u'</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    binary_to_ascii( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)va_arg( va_store, <span class="keyword">int</span> ) );</span><br><span class="line">                    p_to_char++;		<span class="comment">//数据类型匹配</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>( *(p_to_char + <span class="number">1</span>) == <span class="string">'%'</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    putc(*p_to_char++,<span class="built_in">stdout</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            putc(*p_to_char++,<span class="built_in">stdout</span>);</span><br><span class="line">            putc(*p_to_char,<span class="built_in">stdout</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( *p_to_char == <span class="string">'\\'</span> )</span><br><span class="line">            <span class="keyword">if</span>( *(p_to_char - <span class="number">1</span>) == <span class="string">'\''</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>( *(p_to_char + <span class="number">1</span>) == <span class="string">'n'</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    putc(<span class="string">'\n'</span>,<span class="built_in">stdout</span>);</span><br><span class="line">                    p_to_char++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        putc(*p_to_char,<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    va_end(va_store);</span><br><span class="line">    <span class="keyword">return</span> p_to_char - store;							<span class="comment">//记得return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有在<code>''</code>中的才能是转义字符<span class="chineselangcomma">，</span>字符串里的是原型<span class="chineselangstop">。</span></p><h2 id="第八章-数组">第八章-数组</h2><h3 id="sizeof-array-返回整个数组长度">sizeof(array)返回整个数组长度</h3><h3 id="int-array-10-ap-array-2-ap-1-4-1-array-6">int array[10], *ap = array + 2; ap[-1] = 4; 1[array] = 6;</h3><h3 id="下标绝不会比指针更有效率-span-class-chineselangcomma-，-span-但指针有时会比下标更有效率">下标绝不会比指针更有效率<span class="chineselangcomma">，</span>但指针有时会比下标更有效率</h3><p>比如当你在数组中1次n步地移动时<span class="chineselangcomma">，</span>与固定数字相乘的运算在编译时完成<span class="chineselangcomma">，</span>所以在运行时所需的指令就少一些</p><h3 id="不同写法在汇编时的区别P148">不同写法在汇编时的区别P148</h3><h3 id="向函数传递数组时（实参：起始地址-span-class-chineselangcomma-，-span-形参：数组）-span-class-chineselangcomma-，-span-是否声明了一个新数组并初始化为实参的值？">向函数传递数组时（实参：起始地址<span class="chineselangcomma">，</span>形参：数组）<span class="chineselangcomma">，</span>是否声明了一个新数组并初始化为实参的值？</h3><p>否<span class="chineselangstop">。</span><strong>作为形参的数组实际上是一个指针变量而非常量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function1</span><span class="params">(<span class="keyword">int</span> array1[])</span>    <span class="comment">//array1为一个指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array1[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    array1++;             <span class="comment">/*正常运行*/</span></span><br><span class="line">    *++array1 = <span class="number">2</span>;        <span class="comment">/*正常运行*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(array1);			<span class="comment">/*4*/</span> </span><br><span class="line">    <span class="comment">/*warning: ‘sizeof’ on array function parameter ‘a’ will return size of ‘int *’ [-Wsizeof-array-argument]*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">         *<span class="built_in">array</span> = function1(<span class="built_in">array</span>); </span><br><span class="line"> <span class="comment">//        array++;             /*会报错*/</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"array[0]=%d, array[2]=%d"</span>,<span class="built_in">array</span>[<span class="number">0</span>],<span class="built_in">array</span>[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="display:flex;justify-content:center"><div><img src="https://cdn.jsdelivr.net/gh/edfus/storage/images/.io/2019/12/c-yu-zhi-zhen/2019-12-09_155853.png"></div><div><img src="https://cdn.jsdelivr.net/gh/edfus/storage/images/.io/2019/12/c-yu-zhi-zhen/2019-12-09_161025.png"></div></div><br><h3 id="const">const</h3><h3 id="数组的初始化">数组的初始化</h3><ol><li><p>静态数组的初始化</p><blockquote><p>处于静态内存的数组地址不变<span class="chineselangcomma">，</span>每一位自动为0</p><p>程序并不需要执行指令将值赋予<span class="chineselangcomma">，</span>因为它们一开始就在那了</p><p>这个过程由链接器完成<span class="chineselangcomma">，</span>程序执行前已初始化完毕</p></blockquote></li><li><p>自动变量</p><blockquote><p>自动变量位于运行时堆栈中<span class="chineselangcomma">，</span>每次访问时所处的位置可能不同<span class="chineselangcomma">，</span>因此没法在程序开始前进行初始化</p><p>自动变量的初始化其实是用隐式的赋值语句<code>*(array+1)=0</code>等替换了<code>= { , , ... };</code>|<code>= &quot;hello&quot;;（不同写法）</code><span class="chineselangcomma">，</span>和普通赋值语句所消耗的时间空间一样</p></blockquote></li></ol><p><strong>因此<span class="chineselangcomma">，</span>非常庞大数组最好考虑声明为<code>static</code></strong></p><h3 id="多维数组">多维数组</h3><h4 id="多维数组抽象">多维数组抽象</h4><p><span style="color:#3ecb3b;background:#3f3f3f">array[6]:</span></p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p><span style="color:#3ecb3b;background:#3f3f3f"><code>array[6][3]:</code></span>(相当于6个3个元素的一维数组)（既可以用行-列<span class="chineselangcomma">，</span>也可以用列-行）</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="多维数组之数组名含义">多维数组之数组名含义</h4><p><span style="color:#3ecb3b;background:#3f3f3f">int martrix[3][10]</span>: martrix是指向<strong>一个含十个元素的数组的</strong>指针常量（指向数组的指针）</p><p>这就解释了为什么不能<span style="color:#3ecb3b;background:#3f3f3f">int martrix[3][10]</span>, <span style="color:#3ecb3b;background:#3f3f3f">*mp = matrix</span>; //数据类型不匹配<span class="chineselangcomma">，</span>一个是指向整型数组的指针常量<span class="chineselangcomma">，</span>一个是指向整型变量的指针变量</p><h4 id="多维数组间接访问（解引用）">多维数组间接访问（解引用）</h4><p><span style="color:#3ecb3b;background:#3f3f3f">*( *( martrix +1 ) +5 )</span> 不如叫解数组符号好了</p><p>指向指针的指针和指向数组的指针并不是一回事</p><h2 id="第九章-字符串-span-class-chineselangpause-、-span-字符和字节">第九章-字符串<span class="chineselangpause">、</span>字符和字节</h2><h3 id="if-strlen-x-strlen-y-0"><code>if( strlen(x) - strlen(y) &gt;= 0 )</code></h3><p>strlen返回一个类型为size_t（一个无符号整数类型）的值<span class="chineselangcomma">，</span>无符号数之间的操作永远为无符号数</p><p><a href="https://blog.csdn.net/yanxu_165319/article/details/81149595" target="_blank" rel="noopener">sizeof操作符</a>所用也为size_t</p><h3 id="char-strncpy-char-dst-char-const-src-sizr-t-len">char *strncpy( char *dst, char const *src, sizr_t len)</h3><p>如果strlen(src) &lt; len<span class="chineselangcomma">，</span><strong>会用额外的NUL字节填充到len长度</strong></p><p>如果strlen(src) &gt;= len, <sup>注意strlen不包含NUL,sizeof包含</sup> <strong>dst不会以NUL结尾！</strong>（用<span style="color:#3ecb3b;background:#3f3f3f">str[MAX_LEN-1] = '\0'</span>之类的来保证字符串以NUL结尾）</p><h3 id="char-strncat-char-dst-char-const-src-sizr-t-len">char *strncat( char *dst, char const *src, sizr_t len)</h3><ol><li><strong>不会用额外的NUL字节填充len长度</strong></li><li><strong>一定会以NUL结尾（复制len个字符<span class="chineselangcomma">，</span>外加一个NUL字节结尾）</strong></li></ol><h3 id="int-strncmp-char-const-s1-char-const-s2-sizr-t-len">int strncmp( char const *s1, char const *s2, sizr_t len)</h3><p>比较前n个字符<span class="chineselangcomma">，</span>相同返回0</p><h3 id="char-strchr-char-const-str-int-ch-char-strrchr-char-const-str-int-ch">char *strchr(char const *str, int ch); char *strrchr(char const *str, int ch);</h3><p>查找字符ch<span style="color:#3ecb3b;background:#3f3f3f">第一次出现的位置</span>或<span style="color:#3ecb3b;background:#3f3f3f">最后一次出现的位置</span><span class="chineselangcomma">，</span>返回一个指向该位置的指针或NULL</p><h3 id="span-style-color-3ECB3B-background-3F3F3F-strspn-span-span-style-color-3ECB3B-background-3F3F3F-strcspn-span-span-style-color-3ECB3B-background-3F3F3F-strtok-span-span-style-color-3ECB3B-background-3F3F3F-strerror-span-span-style-color-3ECB3B-background-3F3F3F-ctype-h-span"><span style="color:#3ecb3b;background:#3f3f3f">strspn</span> | <span style="color:#3ecb3b;background:#3f3f3f">strcspn</span> | <span style="color:#3ecb3b;background:#3f3f3f">strtok</span> | <span style="color:#3ecb3b;background:#3f3f3f">strerror</span> | <span style="color:#3ecb3b;background:#3f3f3f">&lt;ctype.h&gt;</span> |</h3><h3 id="内存操作（遇到NUL字节时不会停止操作）">内存操作（遇到NUL字节时不会停止操作）</h3><h4 id="void-memcpy-void-dest-const-void-src-size-t-num">void* memcpy(void* dest,const void* src,size_t num)</h4><p>功能：函数memcpy从src的位置开始向后复制num个字节的数据到dest的内存位置</p><h4 id="void-memset-void-str-int-value-size-t-num">void* memset(void* str,int value,size_t num)</h4><ol><li><p>按字节设置<span class="chineselangcomma">，</span>进行赋值</p></li><li><p>功能：以str的起始位置开始的n个字节的内存区域用整数value进行填充</p></li><li><p>返回值：目标str内存起始地址</p></li><li><ul><li><p><strong>memset用来对一段内存空间全部设置为某个字符<span class="chineselangcomma">，</span>一般用在对定义的字符串进行初始化为'\0'或者copy数组</strong></p></li><li><p><strong>如果用malloc分配的内存<span class="chineselangcomma">，</span>一般只能使用memset来初始化</strong></p></li><li><p><strong>memset可以方便的清空一个结构类型的变量或数组,它可以一字节一字节地把整个数组设置为一个指定的值</strong></p></li></ul></li></ol><h2 id="第十章-结构和联合">第十章-结构和联合</h2><h3 id="聚合数据类型-aggregate-data-type-成员-member">聚合数据类型(aggregate data type) 成员 (member)</h3><h3 id="comp-sa-4-c-comp-sa-4-c">( (<a href="http://comp.sa" target="_blank" rel="noopener">comp.sa</a>)[4] ).c = <a href="http://comp.sa" target="_blank" rel="noopener">comp.sa</a>[4].c</h3><h3 id="不完整声明实现结构体的嵌套">不完整声明实现结构体的嵌套</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125; a = &#123;<span class="number">0</span>,&#123;<span class="string">'a'</span>&#125;,<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="成员重排以减少内存损失">成员重排以减少内存损失</h3><h3 id="offsetof-type-member-stddef-h-返回该成员开始存储位置离结构开始存储位置距离">offsetof( type, member ) (stddef.h) 返回该成员开始存储位置离结构开始存储位置距离</h3><h3 id="用指针传递结构体到函数以提高效率（但也要注意不被修改）">用指针传递结构体到函数以提高效率（但也要注意不被修改）</h3><h3 id="位段">位段</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CHAR</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> ch : <span class="number">7</span>;		<span class="comment">//128种字符值</span></span><br><span class="line">    <span class="keyword">unsigned</span> font : <span class="number">6</span>;		<span class="comment">//64种字体</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in">size</span> : <span class="number">19</span>;		<span class="comment">//最多524 287个字符个数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><span style="color:#3ecb3b;background:#3f3f3f">使程序员有效利用ch<span class="chineselangpause">、</span>font剩余的位数来增加size的位数</span><span class="chineselangcomma">，</span>并把位数为奇数的数据包装在一起</p><h4 id="成员必须为int-signed-int-unsigned-int类型">成员必须为int | signed int | unsigned int类型</h4><h4 id="注意事项：">注意事项：</h4><ol><li>int位段有无符号在不同编译器中不同(加上signed/unsigned)</li><li>许多编译器把位段成员的<strong>最大长度限制在一个整型值的长度之内</strong><span class="chineselangcomma">，</span>机器字长对可移植性的影响</li><li>位段中的成员在内存中是从左向右分配的还是从右向左分配的</li><li>溢出时可能重叠</li><li>配合位操作达到更好效果</li></ol><h3 id="联合和枚举">联合和枚举</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VARIABLE</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; INT, FLOAT, STRING &#125; m_type;		<span class="comment">//记录类型</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">float</span> f;			<span class="comment">//按某一种数据类型m_value.x访问这些字节</span></span><br><span class="line">        <span class="keyword">char</span> *s;</span><br><span class="line">    &#125;m_value;</span><br><span class="line">&#125;sDataUnion = &#123;INT,<span class="number">55.9</span>&#125;;    <span class="comment">//实际存储的是55</span></span><br><span class="line"><span class="comment">/*warning: missing braces around initializer [-Wmissing-braces] */</span></span><br><span class="line"><span class="comment">//联合也要记得用&#123;&#125;括起来哦</span></span><br><span class="line">...sDataUnion = &#123;INT,&#123;<span class="number">55.9</span>, <span class="number">33.1</span>&#125;;</span><br><span class="line"><span class="comment">/*warning: excess elements in union initializer*/</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/edfus/storage/images/.io/2019/12/c-yu-zhi-zhen/2019-12-10_161329.png" alt></p><h2 id="第11章-动态内存分配-include-stdlib-h">第11章-动态内存分配#include &lt;stdlib.h&gt;</h2><h3 id="void-malloc-size-t">void *malloc( size_t );</h3><h3 id="void-calloc-size-t-num-elements-size-t-element-size">void *calloc( size_t num_elements, size_t element_size );</h3><h3 id="void-realloc-void-ptr-size-t-new-size">void *realloc( void *ptr, size_t new_size );</h3><ol><li><strong>若ptr指向的内存可以被改变大小<span class="chineselangcomma">，</span>则直接在这块内存的尾部进行加长或截断的操作</strong><span class="chineselangcomma">，</span>若不能<span class="chineselangcomma">，</span>则分配另一块new_size大小的内存，<span style="color:#3ecb3b;background:#3f3f3f">并把原先内存的内容复制到新的块上</span>,释放原有内存</li><li>传递给realloc的指针必须是先前通过<a href="https://baike.baidu.com/item/malloc" target="_blank" rel="noopener">malloc</a>(), <a href="https://baike.baidu.com/item/calloc" target="_blank" rel="noopener">calloc</a>(), 或realloc()分配的</li><li>当ptr = NULL时等同于malloc(), 当new_size = 0时等同于free()</li><li>若内存不够等导致失败则返回NULL<span class="chineselangcomma">，</span>原内存不会被释放</li></ol><h3 id="undef-malloc-P224">#undef malloc P224</h3><h3 id="检查是否调用成功">检查是否调用成功</h3><h2 id="第12章-使用结构和指针-第13章-高级指针话题">第12章-使用结构和指针/第13章-高级指针话题</h2><h3 id="苏小红那本书上的pr指针原来是previous的意思（可以声明为寄存器变量）">苏小红那本书上的pr指针原来是previous的意思（可以声明为寄存器变量）</h3><h3 id="双链表（两个指针指向一前一后）（两个根指针）">双链表（两个指针指向一前一后）（两个根指针）</h3><h3 id="函数只能返回标量值-span-class-chineselangcomma-，-span-不能返回数组">函数只能返回标量值<span class="chineselangcomma">，</span>不能返回数组</h3><h3 id="函数指针">函数指针</h3><h4 id="int-f-int-float-返回整型值形参为整型和浮点型的函数的指针的数组">int ( *f[ ] )( int, float ) 返回整型值形参为整型和浮点型的函数的指针的数组</h4><h4 id="int-f-int-f（编译器隐式转换为函数指针）与-f（显式转换）一样">int f( int ); f（编译器隐式转换为函数指针）与&amp;f（显式转换）一样</h4><h4 id="函数指针数组运用">函数指针数组运用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sub</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mul</span><span class="params">( <span class="keyword">double</span>, <span class="keyword">double</span> )</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">double</span> (*oper_func[])( <span class="keyword">double</span>, <span class="keyword">double</span> ) = &#123;</span><br><span class="line">    add, sub, mul, div, ...						<span class="comment">//一个运算器</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">result = oper_func[ oper ]( op1, op2 );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sub</span><span class="params">(<span class="keyword">void</span> *pa, <span class="keyword">void</span> *pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)*pa - (<span class="keyword">double</span>)*pb;  <span class="comment">/*error: invalid use of void expression*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sub</span><span class="params">(<span class="keyword">void</span> *pa, <span class="keyword">void</span> *pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span> *)pa - *(<span class="keyword">int</span> *)pb;  <span class="comment">/* *pa = 3.14, *pb = 1*/</span></span><br><span class="line">&#125;	<span class="comment">//return 13170115    /* 解引用符号通过指针的数据类型来解读对应内存空间的位们 */</span></span><br><span class="line">	    <span class="keyword">float</span> a = <span class="number">3.14</span>;</span><br><span class="line">        <span class="keyword">int</span> temp1 = a;	<span class="comment">//temp1 = 3</span></span><br><span class="line">        <span class="keyword">int</span> temp2 = (<span class="keyword">int</span>)a; <span class="comment">//temp2 = 3</span></span><br></pre></td></tr></table></figure><h3 id="main函数参数-int-main-int-argc-char-argv-char-envp-int-main-int-argc-char-argv-P265">main函数参数 int main (int argc, char *argv[ ], char *envp[ ]) | int main(int argc,char **argv)P265</h3><p>命令行参数是使用main()函数参数来处理的<span class="chineselangcomma">，</span>其中<span class="chineselangcomma">，</span>argc是指传入参数的个数<span class="chineselangcomma">，</span>argv[]是一个指针数组<span class="chineselangcomma">，</span>指向传递给程序的每个参数<span class="chineselangstop">。</span></p><p>应当指出的是<span class="chineselangcomma">，</span><strong>argv[0]存储程序的名称<span class="chineselangcomma">，</span>argv[1]是一个指向第一个命令行参数的指针</strong><span class="chineselangcomma">，</span>*argv[n]是最后一个参数<span class="chineselangstop">。</span>如果没有提供任何参数<span class="chineselangcomma">，</span>argc 将为1<span class="chineselangcomma">，</span>否则<span class="chineselangcomma">，</span>如果传递了一个参数<span class="chineselangcomma">，</span>argc将被设置为2<span class="chineselangstop">。</span></p><p><strong>多个命令行参数之间用空格分隔<span class="chineselangcomma">，</span>但是如果参数本身带有空格<span class="chineselangcomma">，</span>那么传递参数的时候应把参数放置在双引号或单引号内部</strong><span class="chineselangstop">。</span></p><h3 id="putchar-0123456789ABCDEF-value-16">putchar( &quot;0123456789ABCDEF&quot; [value % 16] );</h3><p>//字符串常量：指针常量 //0~9, A~F 在字符集中不相邻</p><h2 id="第14章-预处理器">第14章-预处理器</h2><h3 id="预定义符号-头文件-include-stdio-h-中">预定义符号(头文件#include&lt;stdio.h&gt;中)</h3><ol><li>__FILE__ 进行编译的源文件名 &quot;name.c&quot;</li><li>__LINE__ 文件当前行的行号 25</li><li>__DATE__ <strong>被编译的</strong>日期 &quot;Jan 31 2019&quot;</li><li>__TIME__ 被编译的时间 &quot;09:21:30&quot;</li><li>__STDC__ ANSI</li></ol><h3 id="define-2">#define</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CASE 			break; case</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_PRINT		printf( <span class="meta-string">"File %s line %d :"</span> \  <span class="comment">//除了最后一行外每一行都要用'\'结尾</span></span></span><br><span class="line">							<span class="string">" x=%d, y=%d, z=%d"</span>,  \	</span><br><span class="line">                 <span class="comment">//与初始化长字符串时一样&lt;span class='chineselangcomma'&gt;，&lt;/span&gt;可以提行（相邻的字符串常量被自动连接为一个字符串）</span></span><br><span class="line">							__FILE__, __LINE__,	  \</span><br><span class="line">							x, y, z );			<span class="comment">//分号</span></span><br></pre></td></tr></table></figure><h4 id="宏替换">宏替换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOUBLE(x)	(x) + (x)			<span class="comment">/*宏*/</span>	<span class="comment">//不能出现递归</span></span></span><br><span class="line">a = <span class="number">5</span>;								<span class="comment">//记得最外层也要用括号括起！</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="number">10</span> * DOUBLE( a ) );</span><br></pre></td></tr></table></figure><h4 id="span-style-color-3ECB3B-background-3F3F3F-argument-span"><span style="color:#3ecb3b;background:#3f3f3f"><strong>#argument</strong></span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT(FORMAT,VALUE) \	<span class="comment">//第一行也要加反斜杠</span></span></span><br><span class="line">		<span class="built_in">printf</span>( <span class="string">"The value of "</span> #VALUE \	<span class="comment">/*#argument结构会被替换成参数名（字符串形式）*/</span></span><br><span class="line">		<span class="string">" is "</span> FORMAT <span class="string">"\n"</span>, VALUE) 	<span class="comment">// 利用字符串自动拼接 	//VALUE为值的形式</span></span><br><span class="line">...</span><br><span class="line">    PRINT( <span class="string">"%d"</span>, x + <span class="number">3</span> );</span><br></pre></td></tr></table></figure><h4 id="宏与函数">宏与函数</h4><ol><li><p>调用宏所用的资源一般小于函数</p></li><li><p><strong>函数的参数必须声明为一种类型<span class="chineselangcomma">，</span>而宏则不需</strong></p></li><li><pre><code class="language-c"> #define MALLOC(n, type) \
 		( (type *)malloc( (n) * sizeof( type ) ) )
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 函数有函数指针&lt;span class&#x3D;&#39;chineselangcomma&#39;&gt;，&lt;&#x2F;span&gt;而宏不行</span><br><span class="line"></span><br><span class="line">5. 宏会大幅度增加代码长度&lt;span class&#x3D;&#39;chineselangcomma&#39;&gt;，&lt;&#x2F;span&gt;而函数重复调用同一份代码</span><br><span class="line"></span><br><span class="line">#### 带副作用的宏参数</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">#define MAX( a, b ) ( (a) &gt; (b) ? (a) : (b) )</span><br><span class="line">...</span><br><span class="line">    x &#x3D; 5;</span><br><span class="line">y &#x3D; 8;</span><br><span class="line">z &#x3D; MAX( x++, y++);		&#x2F;&#x2F;x&#x3D;6, y&#x3D;10, z&#x3D;9</span><br><span class="line">ch &#x3D; EVEVPARITY( getchar() ); &#x2F;&#x2F;多次</span><br></pre></td></tr></table></figure></code></pre></li></ol><h4 id="undef-移除一个宏定义">#undef 移除一个宏定义</h4><p>如果一个现存宏需要重定义<span class="chineselangcomma">，</span>旧定义必须先用#undef移除</p><h4 id="命令行定义P285">命令行定义P285</h4><h3 id="条件编译（见环境）">条件编译（见环境）</h3><h3 id="文件包含">文件包含</h3><p>嵌套包含</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TRYOUT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRYOUT_H_INCLUDED 1</span></span><br><span class="line"><span class="comment">//与</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRYOUT_H_INCLUDED <span class="comment">//效果一样</span></span></span><br></pre></td></tr></table></figure><h3 id="其他指令">其他指令</h3><h4 id="error">#error</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z:\<span class="number">2</span>c-project\trial\tryout.h|<span class="number">4</span>|error: <span class="meta">#<span class="meta-keyword">error</span> sb|</span></span><br></pre></td></tr></table></figure><p>编译时显示出错</p><h4 id="line-progma-无效指令">#line #progma #无效指令</h4><h2 id="第15章-输入-输出函数">第15章-输入/输出函数</h2><h3 id="void-perror-char-const-message-include-stdio-h-errno-errno-h">void perror( char const *message ); #include&lt;stdio.h&gt; errno &lt;errno.h&gt;</h3><p>perror打印出message： 和一条用于解释errno当前值的信息</p><p>只有当一个库函数失败时, errno才会被设置<span class="chineselangcomma">，</span>无错的时候显示ERROR 0</p><p>输出到stderr <a href="https://blog.csdn.net/weixin_41413441/article/details/80534906" target="_blank" rel="noopener">perror(&quot; Hello World!!\n&quot;),相当于fprintf（stderr<span class="chineselangcomma">，</span>&quot;Hello World!!\n&quot;）</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FILE* input;</span><br><span class="line">input = fopen( <span class="string">"data3"</span>, <span class="string">"r"</span> );</span><br><span class="line"><span class="keyword">if</span>( input == <span class="literal">NULL</span> )&#123;</span><br><span class="line">    perror(<span class="string">"data3"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="void-exit-int-status">void exit( int status );</h3><p>常在调用perror之后再调用exit终止程序 EXIT_SUCCESS | EXIT_FAILURE（1）</p><h3 id="ANSI-I-O">ANSI I/O</h3><h4 id="program-data-answer">$ program &lt; data &gt; answer</h4><h4 id="打开文件的最大数量FOPEN-MAX-（至少是8）与FILENAME-MAX">打开文件的最大数量FOPEN_MAX （至少是8）与FILENAME_MAX</h4><h3 id="span-style-color-3ECB3B-background-3F3F3F-fread-span-span-style-color-3ECB3B-background-3F3F3F-fwrite-span-用于读取（写入）二进制数据"><span style="color:#3ecb3b;background:#3f3f3f">fread</span> | <span style="color:#3ecb3b;background:#3f3f3f">fwrite</span>用于读取（写入）二进制数据</h3><p>所以当初写成绩管理系统的时候会有乱码</p><h3 id="fopen-打开一个特定流用于容纳）-a-若文件不存在-span-class-chineselangcomma-，-span-会创建该文件">fopen(打开一个特定流用于容纳） &quot;a&quot; 若文件不存在<span class="chineselangcomma">，</span>会创建该文件</h3><h3 id="FILE-freopen-char-const-filename-char-const-mode-FILE-stream">FILE *freopen(char const *filename, char const *mode, FILE *stream );</h3><p>freopen先试图关闭这个stream<span class="chineselangcomma">，</span>然后用指定的文件和模式重新打开这个流（载入）</p><p>常见操作是 freopen( &quot;data.txt&quot;,&quot;r&quot;, stdin ) == NULL 从文件输入</p><h3 id="int-ungetc-int-character-FILE-stream-将先前读入的字符返回流中">int ungetc( int character, FILE *stream ); 将先前读入的字符返回流中</h3><h3 id="int-sscanf-char-const-string-char-const-format-从字符串中读取字符">int sscanf( char const *string, char const *format,...)从字符串中读取字符</h3><h3 id="scanf-span-style-color-3ECB3B-background-3F3F3F-xxx-span-格式码">scanf <span style="color:#3ecb3b;background:#3f3f3f">[xxx]</span> <a href="https://blog.csdn.net/wan_shibugong/article/details/82225271" target="_blank" rel="noopener">格式码</a></h3><p><strong>此格式控制符的基本格式为：%[scanfset]</strong></p><p>scanfset 有两种形式：一种是以非 “^” 字符开头的 scanset , 表示在读入字符串时将匹配所有在 scanfset 中出现的字符<span class="chineselangcomma">，</span><strong>遇到非scanfset 中的字符时输入就结束</strong>；另外一种形式是以 “^” 字符开头的scanfset <span class="chineselangcomma">，</span>表示在读入字符串时将匹配所有不在scanfset 中出现的字符<span class="chineselangcomma">，</span>遇到scanfset 中的字符<strong>输入就结束<span class="chineselangstop">。</span></strong></p><p>当“-”出现在<strong>scanfset</strong>中且两边都有字符时<span class="chineselangcomma">，</span>大多数编译器都做了如下所述实现：“-”表示匹配从其左边的字符到右边字符之间所有的字符（按ASCII码排序）<span class="chineselangstop">。</span>如a-z表示a到z的所有字符<span class="chineselangcomma">，</span>又如0-9表示0到9这十个数字<span class="chineselangstop">。</span>所以<span class="chineselangcomma">，</span>当scanfset为0-9时表示只匹配数字串<span class="chineselangcomma">，</span>当scanfset为A-Za-z时表示只匹配字符（包括大小写）<span class="chineselangcomma">，</span>当scanfset为^0-9时不匹配所有数字<span class="chineselangstop">。</span>注意<span class="chineselangcomma">，</span>“-”的字符只有在其左右两边都有有效字符时才有这个作用<span class="chineselangcomma">，</span>否则被认为是普通字符<span class="chineselangcomma">，</span>如“ 0-4-6-9”匹配的字符为｛0,1,2,3,4,-,6,7,8,9｝<span class="chineselangcomma">，</span>这样也为输入“-”字符提供了方法<span class="chineselangstop">。</span> （<strong>0-4</strong> - <strong>6-9</strong>）</p><p><strong>可用来读入含空格的字符串</strong></p><h3 id="printf格式标志-0">printf格式标志 <code>-</code> <code>0</code> <code>+</code><code></code> <code>#</code></h3><ol><li>%-d :左对齐</li><li>%+d :若值非负<span class="chineselangcomma">，</span>则向其添加一个负号</li><li>% d :若值非负<span class="chineselangcomma">，</span>则向其前添加一个空格<span class="chineselangcomma">，</span>负数不变<span class="chineselangcomma">，</span>与+号相排斥<span class="chineselangcomma">，</span>优先级更低</li><li># :0 -产生的值以一个0开头 #x -向非零值前添加0x（或0X）#e #f #g 始终保留小数点</li></ol><h3 id="printf-d-“原样替换”">printf %*d “原样替换”</h3><p>printf(&quot;%*d&quot;,2,123);//输出为:123,相当于%2d输出的效果,因为123位数超过2,故原样输出,且为默认的右对齐.</p><p>printf(&quot;%*2d&quot;,1,123);//输出应为[9个空格][123],即相当于%12d输出的效果.</p><h3 id="二进制I-O-（效率很高-span-class-chineselangcomma-，-span-用于另一个程序将按顺序阅读时）">二进制I/O （效率很高<span class="chineselangcomma">，</span>用于另一个程序将按顺序阅读时）</h3><h3 id="刷新和定位函数">刷新和定位函数</h3><h3 id="改变缓存方式P318">改变缓存方式P318</h3><h3 id="流错误函数">流错误函数</h3><h3 id="临时文件">临时文件</h3><h3 id="文件操作函数">文件操作函数</h3><h2 id="第16章-标准函数库P327">第16章-标准函数库P327</h2><h2 id="第17章-经典抽象数据类型">第17章-经典抽象数据类型</h2><h3 id="define-STACK-TYPE-int-push-pop">#define STACK_TYPE int | push | pop</h3><p>用数组实现堆栈：关键为设立一个下标标识用变量<span class="chineselangcomma">，</span>对该变量进行操作</p><h3 id="循环数组-front下标和rear下标分两头">循环数组: front下标和rear下标分两头</h3><h3 id="二叉搜索树">二叉搜索树</h3><ol><li>每个节点的值比它的左子树的所有节点的值都要大<span class="chineselangcomma">，</span>但比它的右子树的所有节点的值都要小</li><li>用关键词查找数据的优秀工具</li><li>据说在实际数据库中<span class="chineselangcomma">，</span>二叉树用来索引<span class="chineselangcomma">，</span>而存储数据是数组</li><li>树根 （顶部） | 叶节点（没有孩子的节点）（底部）</li><li>前序|中序|后序|层次 递归遍历</li></ol><ul><li>前序：遍历左子树到底</li></ul><h3 id="define实现泛型">define实现泛型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #表示：对应变量字符串化</span></span><br><span class="line"><span class="comment">// ##表示：把宏参数名与宏定义代码序列中的标识符连接在一起&lt;span class='chineselangcomma'&gt;，&lt;/span&gt;形成一个新的标识符</span></span><br><span class="line"><span class="comment">//##起到连接作用,比如is_empty##SUFFIX(),SUFFIX为_int,即最后生成is_empty_int()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GNERIC_STACK(STACK_TYPE,SUFFIX,STACK_SIZE)  \</span></span><br><span class="line">	<span class="keyword">static</span> STACK_TYPE <span class="built_in">stack</span>##SUFFIX[STACK_SIZE];    \</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> top_element##SUFFIX=<span class="number">-1</span>;			    \</span><br><span class="line">	<span class="keyword">bool</span> is_empty##SUFFIX()&#123;						\</span><br><span class="line">		<span class="keyword">return</span> top_element##SUFFIX==<span class="number">-1</span>;			    \</span><br><span class="line">	&#125;                       					    \</span><br><span class="line">													\</span><br><span class="line">	<span class="keyword">bool</span> is_full##SUFFIX()&#123;							\</span><br><span class="line">		<span class="keyword">return</span> top_element##SUFFIX==STACK_SIZE<span class="number">-1</span>;	\</span><br><span class="line">	&#125;												\</span><br><span class="line">													\</span><br><span class="line">	<span class="keyword">void</span> push##SUFFIX(STACK_TYPE val)&#123;				\</span><br><span class="line">		assert(!is_full##SUFFIX());					\</span><br><span class="line">		top_element##SUFFIX+=<span class="number">1</span>;						\</span><br><span class="line">		<span class="built_in">stack</span>##SUFFIX[top_element##SUFFIX]=val;		\</span><br><span class="line">	&#125;												\</span><br><span class="line">													\</span><br><span class="line">	<span class="keyword">void</span> pop##SUFFIX()&#123;								\</span><br><span class="line">		assert(!is_empty##SUFFIX());				\</span><br><span class="line">		top_element##SUFFIX-=<span class="number">1</span>;						\</span><br><span class="line">	&#125;												\</span><br><span class="line">													\</span><br><span class="line">	STACK_TYPE top##SUFFIX()&#123;						\</span><br><span class="line">		assert(!is_empty##SUFFIX());   				\</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">stack</span>##SUFFIX[top_element##SUFFIX];	\</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GNERIC_STACK(<span class="keyword">double</span>,_double,<span class="number">10</span>)</span><br><span class="line">GNERIC_STACK(<span class="keyword">int</span>,_int,<span class="number">10</span>)     <span class="comment">//注意不加';'</span></span><br></pre></td></tr></table></figure><h2 id="第十八章-运行时环境">第十八章-运行时环境</h2><h3 id="汇编P420">汇编P420</h3><p><br><br></p><hr><br><ul class="contains-task-list"><li class="task-list-item enabled"><p><label><input class="task-list-item-checkbox" checked type="checkbox"> [^n]: template</label></p></li><li class="task-list-item enabled"><p><label><input class="task-list-item-checkbox" checked type="checkbox"> [^1]: 头文件中其实只包含了这些函数的声明和一些宏定义<span class="chineselangcomma">，</span>真正的函数定义在库中<span class="chineselangcomma">，</span>编译时无用<span class="chineselangcomma">，</span>链接时才发挥作用</label></p></li><li class="task-list-item enabled"><p><label><input class="task-list-item-checkbox" type="checkbox"> [^2]:</label></p></li><li class="task-list-item enabled"><p><label><input class="task-list-item-checkbox" type="checkbox"> [^3]:</label></p></li><li class="task-list-item enabled"><p><label><input class="task-list-item-checkbox" checked type="checkbox"> [^4]: C 中的整型运算是封闭的<span class="chineselangcomma">，</span>即两个 int 型数做加减乘除取余运算以后<span class="chineselangcomma">，</span>结果仍是一个 int 型数</label></p></li><li class="task-list-item enabled"><p><label><input class="task-list-item-checkbox" type="checkbox"> [^5]: 参见《一杯茶<span class="chineselangcomma">，</span>一根烟<span class="chineselangcomma">，</span>一个BUG改一天》一文对此的详细讨论(书诚不欺我也）</label></p></li><li class="task-list-item enabled"><p><label><input class="task-list-item-checkbox" type="checkbox"> [^6]:</label></p></li></ul></div><footer class="article-footer"><a data-url="https://edfus.github.io/2019/12/c-yu-zhi-zhen/" data-id="ckbecsvl3000flsvf7iikc7d5" data-clipboard-text="《C与指针》笔记
https://edfus.xyz/2019/12/c-yu-zhi-zhen/" class="article-share-link">Share</a><div class="article-share-success">Share link copied</div><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/categories/tech/C/" rel="tag">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/categories/tech/笔记/" rel="tag">笔记</a></li></ul></footer></div><nav id="article-nav"></nav></article></section></div><footer id="footer"><div id="footer-info">&copy; 2020 edfus<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a><br><span class="post-count">站点总字数：51.5万+</span><br>♪ <span id="footer-song-name"><span class="delay0" style="animation:none 3.6s linear infinite;animation-delay:0ms">最</span><span class="delay1" style="animation:none 3.6s linear infinite;animation-delay:.4s">も</span><span class="delay2" style="animation:none 3.6s linear infinite;animation-delay:.8s">澄</span><span class="delay3" style="animation:none 3.6s linear infinite;animation-delay:1.2s">み</span><span class="delay4" style="animation:none 3.6s linear infinite;animation-delay:1.6s">わ</span><span class="delay5" style="animation:none 3.6s linear infinite;animation-delay:2s">た</span><span class="delay6" style="animation:none 3.6s linear infinite;animation-delay:2.4s">る</span><span class="delay7" style="animation:none 3.6s linear infinite;animation-delay:2.8s">空</span><span class="delay8" style="animation:none 3.6s linear infinite;animation-delay:3.2s">と</span><span class="delay9" style="animation:none 3.6s linear infinite;animation-delay:3.6s">海</span></span></div></footer><style>#footer a{color:#2ab8ff;background-color:rgba(0,0,0,.05);text-decoration:none;outline:0;-webkit-transition:all .2s ease-in-out;-moz-transition:all .2s ease-in-out;-ms-transition:all .2s ease-in-out;transition:all .2s ease-in-out}#footer a:hover{color:#00ffce}#footer{background:linear-gradient(black,transparent),url(https://cdn.jsdelivr.net/gh/edfus/storage/images/footer-reimu.png),#121621;border-top:1px solid #fff;color:#fff;margin:20px auto 0;overflow:hidden;width:100%;background-repeat:no-repeat,no-repeat,no-repeat;background-position:0 0,calc(60% + 40px) 40%,0 0;background-size:contain}#footer-info{line-height:1.6em;font-size:.85em;padding:50px 20px;margin:0 auto;width:854px}@media screen and (max-width:479px){#footer{margin:0}#footer-info{padding:20px 0 20px 20px;width:calc(97.5% - 20px)}}</style></div><nav id="mobile-nav"><a href="/" class="mobile-nav-link">Home</a> <a href="/categories/tech/" class="mobile-nav-link">Tech</a> <a href="/about/" class="mobile-nav-link">About</a> <a href="/more/" class="mobile-nav-link">More</a></nav><script src="https://apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script><script>"undefined"==typeof jQuery&&document.write(unescape("%3Cscript src='https://cdn.jsdelivr.net/gh/edfus/storage/js/jquery-2.0.3.min.js' type='text/javascript'%3E%3C/script%3E"))</script><a href="#" class="gotop"><img src="https://cdn.jsdelivr.net/gh/edfus/storage/up.png" alt="go to top"></a><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/edfus/storage/fancybox/jquery.fancybox.css"><script src="https://cdn.jsdelivr.net/gh/edfus/storage/fancybox/jquery.fancybox.pack.js"></script><script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll@15.0.0/dist/smooth-scroll.polyfills.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/gh/edfus/storage/js/script.js"></script></div></body></html>